### This document describes each table, its purpose, keys, relationships, columns, constraints, and example values. It aligns with the Phase 2 schema (3NF) and the DDL in ``sql/01_schema/``.

## 1) ``core.users``
****
**Purpose:** Customer accounts and basic demographics.\
**PK:** ``user_id`` (BIGINT identity)\
**Relationships:**
-   ``users.user_id`` -> ``orders.user_id`` (1->M)
- ``users.user_id`` -> ``events.user_id`` (1->M)

| Column | Type | Constraints | Description | Example |
|---|---|---|---|---|
| **user_id** | BIGINT | PK, GENERATED BY DEFAULT AS IDENTITY | Surrogate user key | 101 |
| email | VARCHAR(255) | NOT NULL, UNIQUE, `chk_email_format` | Email address | jane@acme.com |
| first_name | VARCHAR(100) |  | Given name | Jane |
| last_name | VARCHAR(100) |  | Family name | Doe |
| age | INT | CHECK 18–120 | Age (optional) | 31 |
| gender | VARCHAR(20) |  | Optional gender label | Female |
| country | VARCHAR(100) |  | Country/region | Germany |
| created_at | TIMESTAMPTZ | NOT NULL DEFAULT now() | Account creation time | 2025-01-31 10:45:00+00 |

**Indexes:** `idx_users_email`, `idx_users_country`, `idx_users_created_at`  
**Notes:** Store only stable attributes; avoid marketing flags here (use a separate table if needed).

---

## 2) `core.products`
**Purpose:** Product catalog (what is sold).  
**PK:** **`product_id`** (BIGINT identity)  
**Relationships:**  
- `products.product_id` → `inventory_items.product_id` (1→M)  
- `products.product_id` → `order_items.product_id` (1→M)

| Column | Type | Constraints | Description | Example |
|---|---|---|---|---|
| **product_id** | BIGINT | PK, identity | Surrogate product key | 5001 |
| name | VARCHAR(255) | NOT NULL | Product name | “Trail Runner 2.0” |
| category | VARCHAR(100) |  | Category/browse group | Shoes |
| brand | VARCHAR(100) |  | Brand label | Acme |
| department | VARCHAR(100) |  | Higher-level grouping | Sports |
| cost | NUMERIC(10,2) | NOT NULL, `cost >= 0` | Internal cost | 49.00 |
| retail_price | NUMERIC(10,2) | NOT NULL, `retail_price >= cost` | List price | 69.99 |
| sku | VARCHAR(50) | UNIQUE | Stock keeping unit | TR-2-BK-42 |
| created_at | TIMESTAMPTZ | NOT NULL DEFAULT now() | Catalog add time | 2025-02-01 12:00:00+00 |

**Indexes:** `idx_products_category`, `idx_products_brand`, `idx_products_department`  
**Notes:** Do not store inventory counts here; use `inventory_items`.

---

## 3) `core.distribution_centers`
**Purpose:** Locations where inventory is stored/shipped from.  
**PK:** **`center_id`** (BIGINT identity)  
**Relationships:**  
- `distribution_centers.center_id` → `inventory_items.product_distribution_center_id` (1→M)

| Column | Type | Constraints | Description | Example |
|---|---|---|---|---|
| **center_id** | BIGINT | PK, identity | Surrogate key | 11 |
| name | VARCHAR(255) | NOT NULL | Center name | “EU West DC-1” |
| latitude | NUMERIC(10,7) |  | Lat (WGS84) | 51.5098650 |
| longitude | NUMERIC(10,7) |  | Lon (WGS84) | -0.1180920 |

**Indexes:** _None currently_  
**Notes:** Optional geo fields for mapping/nearest-center logic.

---

---

## 4) `core.inventory_items`
**Purpose:** Each physical inventory unit (or batch) tied to a product and (optionally) a distribution center.  
**PK:** **`inventory_item_id`** (BIGINT identity)  
**Relationships:**  
- FK `product_id` → `products.product_id`  
- FK `product_distribution_center_id` → `distribution_centers.center_id`  
- Referenced by `order_items.inventory_item_id` (0→1 mapping if tracked per unit)

| Column | Type | Constraints | Description | Example |
|---|---|---|---|---|
| **inventory_item_id** | BIGINT | PK, identity | Unique inventory record | 9000001 |
| product_id | BIGINT | NOT NULL, FK | Product of this unit | 5001 |
| product_distribution_center_id | BIGINT | FK (nullable) | Where it’s stored | 11 |
| created_at | TIMESTAMPTZ | NOT NULL DEFAULT now() | When stocked | 2025-02-02 09:00:00+00 |
| sold_at | TIMESTAMPTZ |  | When sold (if sold) | 2025-02-10 15:40:00+00 |
| cost | NUMERIC(10,2) | `cost >= 0` OR NULL | Unit or batch cost | 47.50 |

**Indexes:** _Implicit via FKs_; consider adding a DC index if routing queries are frequent.  
**Notes:** If you track batches, document the grain (unit vs batch) in your README.

---

## 5) `core.orders`
**Purpose:** Customer orders (header-level record).  
**PK:** **`order_id`** (BIGINT identity)  
**Relationships:**  
- FK `user_id` → `users.user_id`  
- Referenced by `order_items.order_id` (1→M)

| Column | Type | Constraints | Description | Example |
|---|---|---|---|---|
| **order_id** | BIGINT | PK, identity | Order header id | 730001 |
| user_id | BIGINT | NOT NULL, FK | Who placed the order | 101 |
| status | VARCHAR(50) | NOT NULL, CHECK in set | Lifecycle status: `Complete|Cancelled|Processing|Shipped|Returned` | Shipped |
| created_at | TIMESTAMPTZ | NOT NULL DEFAULT now() | Order creation time | 2025-03-01 08:10:00+00 |
| returned_at | TIMESTAMPTZ |  | Order-level return time (if all items returned) | 2025-03-20 14:05:00+00 |
| shipped_at | TIMESTAMPTZ |  | Shipment time | 2025-03-02 12:00:00+00 |
| delivered_at | TIMESTAMPTZ |  | Delivery time | 2025-03-03 16:20:00+00 |
| num_of_item | INT | `>= 0` or NULL | Redundant count (optional), can be derived | 3 |
| chk_date_flow | CONSTRAINT | shipped ≥ created; delivered ≥ shipped | Ensures time order | — |

**Indexes:** `idx_orders_user_id`, `idx_orders_status`, `idx_orders_created_at`  
**Notes:** Monetary totals are **not** stored here; use an analytical view to sum `order_items.sale_price`.

---

## 6) `core.order_items`
**Purpose:** Line items connecting orders to products/inventory; where per-item prices live.  
**PK:** **`order_item_id`** (BIGINT identity)  
**Relationships:**  
- FK `order_id` → `orders.order_id`  
- FK `user_id` → `users.user_id`  
- FK `product_id` → `products.product_id`  
- FK `inventory_item_id` → `inventory_items.inventory_item_id` (nullable)

| Column | Type | Constraints | Description | Example |
|---|---|---|---|---|
| **order_item_id** | BIGINT | PK, identity | Line id | 73000101 |
| order_id | BIGINT | NOT NULL, FK | Parent order | 730001 |
| user_id | BIGINT | NOT NULL, FK | Denormalized FK to user (joins faster; consistent with source) | 101 |
| product_id | BIGINT | NOT NULL, FK | Purchased product | 5001 |
| inventory_item_id | BIGINT | FK (nullable) | Physical unit shipped | 9000001 |
| status | VARCHAR(50) |  | Optional line status | Delivered |
| sale_price | NUMERIC(10,2) | NOT NULL, `>= 0` | Actual paid price (after discounts/taxes if applicable) | 64.99 |
| created_at | TIMESTAMPTZ | NOT NULL DEFAULT now() | Line creation time | 2025-03-01 08:10:05+00 |
| shipped_at | TIMESTAMPTZ |  | Line ship time | 2025-03-02 12:01:00+00 |
| delivered_at | TIMESTAMPTZ |  | Line delivery time | 2025-03-03 16:21:00+00 |
| returned_at | TIMESTAMPTZ |  | Line return time | 2025-03-18 10:00:00+00 |

**Indexes:** `idx_oi_order_id`, `idx_oi_product_id`, `idx_oi_created_at`, composite `idx_oi_created_product (created_at, product_id)`  
**Notes:** Keep per-line amounts here; do **not** copy product attributes (name, brand, etc.).

---

## 7) `core.events`
**Purpose:** Lightweight web/app analytics (sessions, pageviews, clicks, etc.).  
**PK:** **`event_id`** (BIGINT identity)  
**Relationships:**  
- FK `user_id` → `users.user_id` (nullable to allow anonymous events)

| Column | Type | Constraints | Description | Example |
|---|---|---|---|---|
| **event_id** | BIGINT | PK, identity | Event id | 42000001 |
| user_id | BIGINT | FK (nullable) | User who triggered event (if logged in) | 101 |
| sequence_number | INT |  | Event order within a session | 12 |
| session_id | VARCHAR(255) |  | Session correlation id | sess_c7d…a1f |
| created_at | TIMESTAMPTZ | NOT NULL DEFAULT now() | Event timestamp | 2025-03-04 09:12:00+00 |
| ip_address | INET |  | Source IP | 81.24.10.12 |
| city | VARCHAR(100) |  | Geo (optional) | Essen |
| state | VARCHAR(100) |  | Region/state | NW |
| postal_code | VARCHAR(20) |  | Postal code | 45127 |
| browser | VARCHAR(100) |  | User agent family | Chrome |
| traffic_source | VARCHAR(100) |  | Campaign/referrer | google / cpc |
| uri | TEXT |  | Visited path | /product/5001 |
| event_type | VARCHAR(50) |  | Click, PageView, AddToCart, etc. | PageView |

**Indexes:** `idx_events_user_id`, `idx_events_session_id`, `idx_events_created_at`, `idx_events_event_type`  
**Notes:** Keep values small; high-cardinality fields (e.g., full UA) can be split to a dim table if needed.

---

## Relationship Summary (FK Matrix)

| From table.column | → | To table.column | Cardinality |
|---|---|---|---|
| core.orders.user_id | → | core.users.user_id | users 1 → M orders |
| core.order_items.order_id | → | core.orders.order_id | orders 1 → M order_items |
| core.order_items.user_id | → | core.users.user_id | users 1 → M order_items |
| core.order_items.product_id | → | core.products.product_id | products 1 → M order_items |
| core.order_items.inventory_item_id | → | core.inventory_items.inventory_item_id | inventory_items 0/1 → 0/1 order_items |
| core.inventory_items.product_id | → | core.products.product_id | products 1 → M inventory_items |
| core.inventory_items.product_distribution_center_id | → | core.distribution_centers.center_id | centers 1 → M inventory_items |
| core.events.user_id | → | core.users.user_id | users 1 → M events |

---

## Derived Fields & Views (for Phase 3/4)
- **Order totals view:** Sum `order_items.sale_price` grouped by `order_id`.  
- **Customer RFM view:** Recency (max `orders.created_at`), Frequency (count orders), Monetary (sum sale_price).  
- **Product performance:** Sum `sale_price` and count `order_items` per `product_id` by month.

---

## Data Quality Rules (quick checks)
- Emails match regex; are unique.  
- `orders.chk_date_flow` satisfied (temporal consistency).  
- `retail_price >= cost`, `sale_price >= 0`.  
- No product attributes stored outside `products`.  
- All FKs resolve (no orphans).

---

## Example Validation Queries

```sql
-- FK integrity (no orphaned order_items)
SELECT oi.*
FROM core.order_items oi
LEFT JOIN core.orders o ON o.order_id = oi.order_id
WHERE o.order_id IS NULL
LIMIT 10;

-- Temporal sanity (delivered before shipped?)
SELECT order_id, shipped_at, delivered_at
FROM core.orders
WHERE delivered_at IS NOT NULL AND shipped_at IS NOT NULL
  AND delivered_at < shipped_at;

-- Price constraints
SELECT *
FROM core.products
WHERE retail_price < cost;